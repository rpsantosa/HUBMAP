{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "32c52d47",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-26T07:35:32.946686Z",
     "iopub.status.busy": "2021-05-26T07:35:32.943773Z",
     "iopub.status.idle": "2021-05-26T07:36:27.643336Z",
     "shell.execute_reply": "2021-05-26T07:36:27.641700Z"
    },
    "papermill": {
     "duration": 54.710878,
     "end_time": "2021-05-26T07:36:27.643552",
     "exception": false,
     "start_time": "2021-05-26T07:35:32.932674",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "── \u001b[1mAttaching packages\u001b[22m ─────────────────────────────────────── tidyverse 1.3.0 ──\n",
      "\n",
      "\u001b[32m✔\u001b[39m \u001b[34mggplot2\u001b[39m 3.3.3     \u001b[32m✔\u001b[39m \u001b[34mpurrr  \u001b[39m 0.3.4\n",
      "\u001b[32m✔\u001b[39m \u001b[34mtibble \u001b[39m 3.1.1     \u001b[32m✔\u001b[39m \u001b[34mdplyr  \u001b[39m 1.0.5\n",
      "\u001b[32m✔\u001b[39m \u001b[34mtidyr  \u001b[39m 1.1.3     \u001b[32m✔\u001b[39m \u001b[34mstringr\u001b[39m 1.4.0\n",
      "\u001b[32m✔\u001b[39m \u001b[34mreadr  \u001b[39m 1.4.0     \u001b[32m✔\u001b[39m \u001b[34mforcats\u001b[39m 0.5.0\n",
      "\n",
      "── \u001b[1mConflicts\u001b[22m ────────────────────────────────────────── tidyverse_conflicts() ──\n",
      "\u001b[31m✖\u001b[39m \u001b[34mdplyr\u001b[39m::\u001b[32mfilter()\u001b[39m masks \u001b[34mstats\u001b[39m::filter()\n",
      "\u001b[31m✖\u001b[39m \u001b[34mdplyr\u001b[39m::\u001b[32mlag()\u001b[39m    masks \u001b[34mstats\u001b[39m::lag()\n",
      "\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Using virtual environment '/usr/local/share/.virtualenvs/r-reticulate' ...\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "None"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/html": [
       "<table class=\"dataframe\">\n",
       "<caption>A matrix: 2 × 6 of type dbl</caption>\n",
       "<thead>\n",
       "\t<tr><th></th><th scope=col>used</th><th scope=col>(Mb)</th><th scope=col>gc trigger</th><th scope=col>(Mb)</th><th scope=col>max used</th><th scope=col>(Mb)</th></tr>\n",
       "</thead>\n",
       "<tbody>\n",
       "\t<tr><th scope=row>Ncells</th><td>2105310</td><td>112.5</td><td>4224960</td><td>225.7</td><td>4224960</td><td>225.7</td></tr>\n",
       "\t<tr><th scope=row>Vcells</th><td>3603339</td><td> 27.5</td><td>8388608</td><td> 64.0</td><td>5856708</td><td> 44.7</td></tr>\n",
       "</tbody>\n",
       "</table>\n"
      ],
      "text/latex": [
       "A matrix: 2 × 6 of type dbl\n",
       "\\begin{tabular}{r|llllll}\n",
       "  & used & (Mb) & gc trigger & (Mb) & max used & (Mb)\\\\\n",
       "\\hline\n",
       "\tNcells & 2105310 & 112.5 & 4224960 & 225.7 & 4224960 & 225.7\\\\\n",
       "\tVcells & 3603339 &  27.5 & 8388608 &  64.0 & 5856708 &  44.7\\\\\n",
       "\\end{tabular}\n"
      ],
      "text/markdown": [
       "\n",
       "A matrix: 2 × 6 of type dbl\n",
       "\n",
       "| <!--/--> | used | (Mb) | gc trigger | (Mb) | max used | (Mb) |\n",
       "|---|---|---|---|---|---|---|\n",
       "| Ncells | 2105310 | 112.5 | 4224960 | 225.7 | 4224960 | 225.7 |\n",
       "| Vcells | 3603339 |  27.5 | 8388608 |  64.0 | 5856708 |  44.7 |\n",
       "\n"
      ],
      "text/plain": [
       "       used    (Mb)  gc trigger (Mb)  max used (Mb) \n",
       "Ncells 2105310 112.5 4224960    225.7 4224960  225.7\n",
       "Vcells 3603339  27.5 8388608     64.0 5856708   44.7"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "\u001b[36m──\u001b[39m \u001b[1m\u001b[1mColumn specification\u001b[1m\u001b[22m \u001b[36m────────────────────────────────────────────────────────\u001b[39m\n",
      "cols(\n",
      "  id = \u001b[31mcol_character()\u001b[39m,\n",
      "  predicted = \u001b[33mcol_logical()\u001b[39m\n",
      ")\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "library(tensorflow)\n",
    "library(keras)\n",
    "#library(tfdatasets)\n",
    "library(tidyverse)\n",
    "library(reticulate)\n",
    "library(dplyr)\n",
    "#library(sp)\n",
    "#library(jsonlite)\n",
    "#library(data.table)\n",
    "#library(imager)\n",
    "  SIZE <- 256L\n",
    "  SPLIT<- 1024L\n",
    "  thr<- 0.4\n",
    "\n",
    " gpu_devices =  tf$config$experimental$list_physical_devices(\"GPU\")[[1]]\n",
    " tf$config$experimental$set_memory_growth(gpu_devices, T)\n",
    "\n",
    "ff<- list.files(\"../input/reqssss\",full.names=T )   \n",
    "py_install(ff)\n",
    "\n",
    " py<- function(x)py_run_string(x)\n",
    "\n",
    "\n",
    "rasterio<- import(\"rasterio\", convert=F)\n",
    "np<- import(\"numpy\", convert = F)\n",
    "#npx<- import(\"numpy\", convert = T)\n",
    "\n",
    "win<- rasterio$windows\n",
    "logging<- rasterio$logging\n",
    "log<- rasterio$logging$getLogger()\n",
    "log$setLevel(logging$ERROR)\n",
    "\n",
    "\n",
    "TEST<- file.path(\"../input/hubmap-kidney-segmentation/test\")\n",
    "BASE<-file.path(\"../input/hubmap-kidney-segmentation/\")\n",
    "TRAIN<- file.path(\"../input/hubmap-kidney-segmentation/train\" )\n",
    "MODEL<- file.path(\"../input/effb3-models\")\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "bce_dice_loss <- function(y_true, y_pred) {\n",
    "    result <- loss_binary_crossentropy(y_true, y_pred) +\n",
    "        (1 - dice(y_true, y_pred))\n",
    "    return(result)\n",
    "} \n",
    "\n",
    "dice <- custom_metric(\"dice\", function(y_true, y_pred, smooth = 1e-5) {\n",
    "  y_true_f <- k_flatten(y_true)\n",
    "  y_pred_f <- k_flatten(y_pred)\n",
    "  intersection <- k_sum(y_true_f * y_pred_f)\n",
    "  (2 * intersection + smooth) / (k_sum(y_true_f) + k_sum(y_pred_f) + smooth)\n",
    "})\n",
    "cross_loss <- function(y_true, y_pred) {\n",
    "    # y_true<-k_cast(y_true, \"float32\")\n",
    "    # y_pred<-k_cast(y_pred,\"float32\")\n",
    "    result <- loss_binary_crossentropy(y_true, y_pred) + loss_logcosh(y_true, y_pred)* (1 - dice(y_true, y_pred)) #loss_logcosh(y_true, y_pred)* (1 - dice(y_true, y_pred))     # \n",
    "    return(result)\n",
    "} \n",
    "\n",
    "fload<-function(x){ \n",
    "    mm<- load_model_hdf5(file.path(x), custom_objects = c(\"cross_loss\"= cross_loss, \"dice\"=dice), compile = F)\n",
    "    mm\n",
    "}     \n",
    "modelList<-list.files(MODEL,pattern = \".hdf5\",full.names = T)\n",
    "\n",
    "models<- map(modelList,fload)\n",
    "gc()\n",
    "\n",
    "test<-read_csv(file.path(BASE,\"sample_submission.csv\"))\n",
    "#dataset<- read_csv(file.path(BASE,\"HuBMAP-20-dataset_information.csv\"))\n",
    "baseid<- test$id\n",
    "\n",
    "b<- tibble(baseid=baseid, size = list.files(TEST, full.names = T,pattern = \"*.tiff\") %>% file.size/1e9, k = 1: length(baseid))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "5f786cf3",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-26T07:36:27.692572Z",
     "iopub.status.busy": "2021-05-26T07:36:27.667660Z",
     "iopub.status.idle": "2021-05-26T07:36:27.712821Z",
     "shell.execute_reply": "2021-05-26T07:36:27.711505Z"
    },
    "papermill": {
     "duration": 0.057001,
     "end_time": "2021-05-26T07:36:27.712947",
     "exception": false,
     "start_time": "2021-05-26T07:36:27.655946",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "\n",
    "idx2rle <- function(idx) {\n",
    "  if (length(idx) == 0) return(\"\")\n",
    "  \n",
    "  # Make sure  values are sorted\n",
    "  idx <- sort(idx)\n",
    "  \n",
    "  # Array of starting positions and run lengths\n",
    "  starts <- c()\n",
    "  runs <- c()\n",
    "  \n",
    "  # Loop\n",
    "  starts <- c(starts, idx[1])\n",
    "  run <- 1\n",
    "  for (i in 2:length(idx)) { #run\n",
    "    if (idx[i-1] + 1 == idx[i]) {\n",
    "      run <- run + 1\n",
    "    } else { #stop\n",
    "      runs <- c(runs, run)\n",
    "      starts <- c(starts, idx[i])\n",
    "      run <- 1\n",
    "    }\n",
    "  }\n",
    "  \n",
    "  # Last run length needs special handling\n",
    "  runs <- c(runs, run)\n",
    "  \n",
    "  # Sanity check\n",
    "  stopifnot(length(starts) == length(runs))\n",
    "  \n",
    "  # zip starts and runs as space delimited list\n",
    "  return(paste0(mapply(list, paste(starts, runs)), collapse = \" \"))\n",
    "  \n",
    "}\n",
    "\n",
    "\n",
    "make_nn<-function(height,width){\n",
    "  cc<-SPLIT/2\n",
    "  ncolsi<-c( seq(0,width -2*cc, cc),width-2*cc)\n",
    "  nrowsi<-c( seq(0,height-2*cc,  cc), height - 2*cc)\n",
    "  nn<-expand.grid(nrowsi, ncolsi)\n",
    "  names(nn)<- c(\"y\",\"x\")\n",
    "  #nn$id<- 1:nrow(nn)\n",
    "  nn$x <- as.integer( nn$x)\n",
    "  nn$y <- as.integer(nn$y)\n",
    "  #single<- big [(SPLIT/2+1):(SPLIT/2 + SPLIT) ,(SPLIT/2+1):(SPLIT/2 + SPLIT) ]\n",
    "  return(nn) \n",
    "}\n",
    "\n",
    "to_batch_predict<-function(i,j,im=im,channellast){\n",
    "\n",
    "  if(channellast){\n",
    "    imx<-im[(i+1L):(i+SPLIT),(j+1L):(j+SPLIT),] %>%\n",
    "    tf$image$convert_image_dtype(.,tf$float32) \n",
    "  }else\n",
    "  {  imx<-im[,(i+1L):(i+SPLIT),(j+1L):(j+SPLIT)] %>%\n",
    "    k_permute_dimensions(c(2L,3L,1L)) %>%\n",
    "    tf$image$convert_image_dtype(.,tf$float32)\n",
    "  }\n",
    "\n",
    " imx<- imx  %>%\n",
    "  tf$image$resize( size = shape(SIZE,SIZE)) \n",
    " imx\n",
    "}\n",
    "\n",
    "modes <- function(d){\n",
    "    i <- which(diff(sign(diff(d$y))) < 0) + 1\n",
    "    data.frame(x = d$x[i], y = d$y[i])\n",
    "}\n",
    "remove_bw<-function(h,w,layers){\n",
    "  #lets try to filter based on the density information\n",
    "  ### now, applied to all\n",
    "  xx <- read_from_layers(h, w,layers) %>% as.array %>% density( n = 64) %>% modes(.) %>% nrow(.)\n",
    "  return(xx > 10)\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "read_from_layers<- function(h,w,layers){\n",
    "    ww<-win$Window(w,h,SPLIT,SPLIT)\n",
    "    if(length(layers) ==1){\n",
    "      nlayers<- map(1:3,function(i){layers[[1]]$read(i,window=ww)})\n",
    "       out<-tf$stack(nlayers,2L)\n",
    "    }else{\n",
    "      nlayers<- map(layers,function(x){x$read( 1L ,window=ww) } )\n",
    "      out<-tf$stack(nlayers,2L)\n",
    "     }\n",
    "     out<- out %>%  tf$image$convert_image_dtype(.,tf$float32) %>%\n",
    "      tf$image$resize(., size = shape(SIZE,SIZE))\n",
    "      return(out)\n",
    "}\n",
    "HuBMAP<-function(tiff_path){\n",
    "    dataset = rasterio$open(tiff_path, num_threads=\"all_cpus\")\n",
    "    self_layers = list()\n",
    "    if (dataset$count != 3){\n",
    "      subdatasets = dataset$subdatasets\n",
    "      if (length(subdatasets) > 0){\n",
    "        for( i in 0: (length(subdatasets) -1) ){\n",
    "        self_layers<- c(self_layers,(\n",
    "          rasterio$open(subdatasets[i], num_threads=\"all_cpus\")))\n",
    "          }\n",
    "        }\n",
    "      }else{\n",
    "        self_layers<- c(self_layers,(rasterio$open(tiff_path, num_threads=\"all_cpus\")))\n",
    "      }\n",
    "    \n",
    "    layers<- self_layers\n",
    "    height <- dataset$height %>% py_to_r\n",
    "    width<- dataset$width %>% py_to_r\n",
    "    nnc<-make_nn(height,width)\n",
    "    #ibw<- map2(nnc[,1],nnc[,2],remove_bw) %>% unlist\n",
    "    ibw<-c()\n",
    "    for( i in 1:nrow(nnc)){\n",
    "       ibw <- c(ibw,remove_bw(nnc[i,1],nnc[i,2],layers) )\n",
    "     } \n",
    "    gc()\n",
    "    nnc<-nnc[!ibw,]\n",
    "    \n",
    "    chunk2 <- function(x,n) split(x, cut(seq_along(x), n, labels = FALSE))\n",
    "    nn<-ceiling(nrow(nnc)/50) \n",
    "    nlist<-chunk2(1:nrow(nnc),nn)\n",
    "return(list(nlist=nlist,layers=layers, nnc=nnc, height=height, width=width))\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "88385128",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-26T07:36:27.736155Z",
     "iopub.status.busy": "2021-05-26T07:36:27.734394Z",
     "iopub.status.idle": "2021-05-26T07:36:27.745395Z",
     "shell.execute_reply": "2021-05-26T07:36:27.744011Z"
    },
    "papermill": {
     "duration": 0.024055,
     "end_time": "2021-05-26T07:36:27.745493",
     "exception": false,
     "start_time": "2021-05-26T07:36:27.721438",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "sub<-function(k){\n",
    "\n",
    "on.exit(keras::backend()$clear_session())\n",
    " gc()\n",
    "tiff_path<-file.path(TEST,paste0(baseid[k],\".tiff\") )\n",
    "\n",
    "c(nlist,layers,nnc,height,width) %<-%   HuBMAP(tiff_path)\n",
    "\n",
    "gen_preds<-function(ll){\n",
    "  img<- map2(nnc[ll,1],nnc[ll,2],read_from_layers,layers)  %>%map(., function(x)tf$expand_dims(x,axis=0L)) %>%tf$concat(.,axis=0L) \n",
    "  #img<- map2(nnc[ll,1],nnc[ll,2],fa,channellast) %>% map(.,function(x)tf$expand_dims(x,axis=0L))%>% tf$concat(.,axis=0L)\n",
    "  img<-  models %>% map(.,function(x)predict(x,img,batch_size=8)) %>%  tf$math$add_n(.)   %>%\n",
    "    tf$math$divide(.,length(models)) %>%  tf$image$resize( size = shape(SPLIT,SPLIT) )   \n",
    "  gc()\n",
    "  return(img)\n",
    "}      \n",
    "gen_idx<-function(ll){\n",
    "  preds<-gen_preds(ll)\n",
    "    fidx<-function(i){\n",
    "      nrowi<-nnc[i,1] + SPLIT/4\n",
    "      ncoli<-nnc[i,2] + SPLIT/4\n",
    "      big<- preds[which(ll==i),,,1] %>% as.array\n",
    "      pred<- big[(SPLIT/4+1):(SPLIT/4 + SPLIT/2) ,(SPLIT/4+1):(SPLIT/4 + SPLIT/2 ) ]\n",
    "      predx<- pred > thr  \n",
    "      pred[predx]<-1L;pred[!predx]<-0L\n",
    "       #if(sum(pred) ==0)return(NULL)\n",
    "      coord <- which(predx == 1L, arr.ind = T) %>% as.data.frame\n",
    "      idx <-\n",
    "         with(coord, {\n",
    "          (col + ncoli - 1L) * height + row + nrowi\n",
    "        }) %>% as.integer #convert to original size\n",
    "    idx\n",
    "  }\n",
    "  out<- ll %>% map(.,fidx) %>% unlist \n",
    "  gc()\n",
    "  return(out)\n",
    "}\n",
    "                        \n",
    "res<-     nlist %>% map(.,gen_idx) %>% unlist %>% unique %>% sort %>%  idx2rle()\n",
    "gc()\n",
    "return(res)\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "608a44cd",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-26T07:36:27.767270Z",
     "iopub.status.busy": "2021-05-26T07:36:27.765554Z",
     "iopub.status.idle": "2021-05-26T07:36:27.776031Z",
     "shell.execute_reply": "2021-05-26T07:36:27.774701Z"
    },
    "papermill": {
     "duration": 0.022067,
     "end_time": "2021-05-26T07:36:27.776127",
     "exception": false,
     "start_time": "2021-05-26T07:36:27.754060",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "# library(imager)\n",
    "# i=  324\n",
    "# xn<-nnc[i,]\n",
    "# img<- fa(xn[, 1], xn[, 2],channellast) %>% tf$expand_dims(axis=0L)\n",
    "# img %>% tf$squeeze(.) %>% as.array %>% as.raster %>% plot\n",
    "# \n",
    "# pred<- xs_single(i)\n",
    "# pred %>% as.raster %>% plot\n",
    "# summary(pred %>% as.numeric )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "25b651ce",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-26T07:36:27.797544Z",
     "iopub.status.busy": "2021-05-26T07:36:27.795920Z",
     "iopub.status.idle": "2021-05-26T07:36:27.806502Z",
     "shell.execute_reply": "2021-05-26T07:36:27.805204Z"
    },
    "papermill": {
     "duration": 0.021974,
     "end_time": "2021-05-26T07:36:27.806616",
     "exception": false,
     "start_time": "2021-05-26T07:36:27.784642",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [],
   "source": [
    "tsglobal<-proc.time()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "04baf93f",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-26T07:36:27.828314Z",
     "iopub.status.busy": "2021-05-26T07:36:27.826674Z",
     "iopub.status.idle": "2021-05-26T08:32:52.713859Z",
     "shell.execute_reply": "2021-05-26T08:32:52.706083Z"
    },
    "papermill": {
     "duration": 3384.898831,
     "end_time": "2021-05-26T08:32:52.714044",
     "exception": false,
     "start_time": "2021-05-26T07:36:27.815213",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "2ec3f1bb9 \n",
      "3589adb90 \n",
      "d488c759a \n",
      "aa05346ff \n",
      "57512b7f1 \n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "\u001b[36m──\u001b[39m \u001b[1m\u001b[1mColumn specification\u001b[1m\u001b[22m \u001b[36m────────────────────────────────────────────────────────\u001b[39m\n",
      "cols(\n",
      "  id = \u001b[31mcol_character()\u001b[39m,\n",
      "  predicted = \u001b[33mcol_logical()\u001b[39m\n",
      ")\n",
      "\n",
      "\n"
     ]
    }
   ],
   "source": [
    "\n",
    "sub_catch = possibly(.f = sub, otherwise = \"10 2 20 3\")\n",
    "\n",
    "#predicted<-map(1:length(baseid),sub_catch)\n",
    "predicted<-list()\n",
    "for( i in 1:length(baseid)){\n",
    "    predicted<- c( predicted,sub(i))\n",
    "    gc()\n",
    "    cat( baseid[i],\"\\n\")\n",
    "}\n",
    "#predicted<- list(sub(1))\n",
    "hand<-tibble(id=baseid ,predicted=predicted %>% unlist)\n",
    "submission<-read_csv(file.path(BASE,\"sample_submission.csv\"))\n",
    "submission[,2]<- hand[,2] \n",
    "#submission[1,]<-hand\n",
    "\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "9425b4f5",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-26T08:32:53.002537Z",
     "iopub.status.busy": "2021-05-26T08:32:53.001939Z",
     "iopub.status.idle": "2021-05-26T08:32:53.019517Z",
     "shell.execute_reply": "2021-05-26T08:32:53.018079Z"
    },
    "papermill": {
     "duration": 0.288043,
     "end_time": "2021-05-26T08:32:53.019683",
     "exception": false,
     "start_time": "2021-05-26T08:32:52.731640",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "elapsed : 56.4201666666667 minutes"
     ]
    }
   ],
   "source": [
    "tt<-proc.time() -tsglobal\n",
    "cat(paste0(\"elapsed : \", tt[[3]]/60 , \" minutes\"))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "6a61015a",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-26T08:32:53.045508Z",
     "iopub.status.busy": "2021-05-26T08:32:53.043864Z",
     "iopub.status.idle": "2021-05-26T08:32:53.151698Z",
     "shell.execute_reply": "2021-05-26T08:32:53.150280Z"
    },
    "papermill": {
     "duration": 0.12128,
     "end_time": "2021-05-26T08:32:53.151844",
     "exception": false,
     "start_time": "2021-05-26T08:32:53.030564",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "write_csv\n"
     ]
    }
   ],
   "source": [
    "write_csv(submission,\"submission.csv\")\n",
    "cat(\"write_csv\\n\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "4013f2ab",
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-05-26T08:32:53.176029Z",
     "iopub.status.busy": "2021-05-26T08:32:53.174437Z",
     "iopub.status.idle": "2021-05-26T08:32:53.192979Z",
     "shell.execute_reply": "2021-05-26T08:32:53.191617Z"
    },
    "papermill": {
     "duration": 0.031396,
     "end_time": "2021-05-26T08:32:53.193084",
     "exception": false,
     "start_time": "2021-05-26T08:32:53.161688",
     "status": "completed"
    },
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "5666017"
      ],
      "text/latex": [
       "5666017"
      ],
      "text/markdown": [
       "5666017"
      ],
      "text/plain": [
       "[1] 5666017"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "file.size(\"submission.csv\")\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "R",
   "language": "R",
   "name": "ir"
  },
  "language_info": {
   "codemirror_mode": "r",
   "file_extension": ".r",
   "mimetype": "text/x-r-source",
   "name": "R",
   "pygments_lexer": "r",
   "version": "3.6.3"
  },
  "papermill": {
   "default_parameters": {},
   "duration": 3444.579097,
   "end_time": "2021-05-26T08:32:55.049278",
   "environment_variables": {},
   "exception": null,
   "input_path": "__notebook__.ipynb",
   "output_path": "__notebook__.ipynb",
   "parameters": {},
   "start_time": "2021-05-26T07:35:30.470181",
   "version": "2.3.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
